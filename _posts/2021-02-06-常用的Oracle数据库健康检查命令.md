---
layout: post
title:  "2021-02-06-常用的Oracle数据库健康检查命令"
date:   2020-02-06 12:03:36 +0530
categories: Web
tags: [database]
description:
---

### 常用的Oracle数据库健康检查命令

1. 检查是否存在失效索引
查询到数据，说明存在失效索引，需分析失效原因并解决。
```sql
SELECT OWNER, TABLE_NAME, INDEX_NAME, 'NO PARTITION' PARTITION_NAME, STATUS
  FROM DBA_INDEXES I
 WHERE I.STATUS NOT IN ('N/A', 'VALID')
   AND I.INDEX_NAME NOT LIKE 'BIN$%'
UNION ALL
SELECT PI.INDEX_OWNER,
       (SELECT TABLE_NAME
          FROM DBA_INDEXES
         WHERE OWNER = PI.INDEX_OWNER
           AND INDEX_NAME = PI.INDEX_NAME) TABLE_NAME,
       PI.INDEX_NAME,
       PI.PARTITION_NAME,
       PI.STATUS
  FROM DBA_IND_PARTITIONS PI
 WHERE STATUS NOT IN ('N/A', 'USABLE')
   AND INDEX_NAME NOT LIKE 'BIN$%'
UNION ALL
SELECT SPI.INDEX_OWNER,
       (SELECT TABLE_NAME
          FROM DBA_INDEXES
         WHERE OWNER = SPI.INDEX_OWNER
           AND INDEX_NAME = SPI.INDEX_NAME) TABLE_NAME,
       SPI.INDEX_NAME,
       SPI.SUBPARTITION_NAME,
       SPI.STATUS
  FROM DBA_IND_SUBPARTITIONS SPI
 WHERE STATUS NOT IN ('N/A', 'USABLE')
   AND INDEX_NAME NOT LIKE 'BIN$%';
```

2. 检查是否有失效的对象
查询到数据，说明存在失效对象，需分析失效原因并解决。
```sql
SELECT OWNER, OBJECT_NAME, OBJECT_TYPE, CREATED, LAST_DDL_TIME, STATUS
  FROM DBA_OBJECTS WHERE STATUS <> 'VALID';
```

3. 检查锁表情况
查询到数据，间隔3分钟后再次查询，如果还是相同记录，说明长时间锁表，需要分析锁表原因。
```sql
SELECT INST_ID, SID, USERNAME, STATUS, EVENT, SQL_ID, SQL_EXEC_START, MODULE, MACHINE, LOGON_TIME
  FROM GV$SESSION S WHERE S.EVENT LIKE '%enq%';
```

4. 检查耗时长的查询语句
查询到数据，说明查询语句平均耗时超过了10s，建议分析语句耗时长是否正常。
```sql
SELECT INST_ID, PARSING_SCHEMA_NAME, SQL_ID, EXECUTIONS, ELAPSED_TIME, ROWS_PROCESSED, MODULE, LAST_ACTIVE_TIME, LAST_LOAD_TIME, DBMS_LOB.SUBSTR(SQL_FULLTEXT, 3800, 1) SQLTEXT
  FROM GV$SQLAREA WHERE MODULE LIKE 'JDBC%' AND LAST_ACTIVE_TIME >= SYSDATE - 1 AND COMMAND_TYPE = 3
  AND ELAPSED_TIME / DECODE(EXECUTIONS,0,1,EXECUTIONS) > 10000000;
```

5. 检查表空间使用情况
USED_PERCENT应低于80%，超过的话需分析使用情况，扩容或删除不需要的数据、对象。
```sql
SELECT A.TABLESPACE_NAME,
       A.TOTAL_SPACE,
       NVL(B.FREE_SPACE, 0) FREE_SPACE,
       TRUNC((A.TOTAL_SPACE - NVL(B.FREE_SPACE, 0)) / A.TOTAL_SPACE, 3) * 100 || '%' USED_PERCENT
  FROM (SELECT TABLESPACE_NAME,
               TRUNC(SUM(BYTES) / 1024 / 1024, 2) TOTAL_SPACE
          FROM DBA_DATA_FILES
         GROUP BY TABLESPACE_NAME) A,
       (SELECT TABLESPACE_NAME,
               TRUNC(SUM(BYTES) / 1024 / 1024, 2) FREE_SPACE
          FROM DBA_FREE_SPACE
         GROUP BY TABLESPACE_NAME) B
 WHERE A.TABLESPACE_NAME = B.TABLESPACE_NAME(+)
 ORDER BY (A.TOTAL_SPACE - NVL(B.FREE_SPACE, 0)) / A.TOTAL_SPACE DESC
```

6. 检查临时表空间使用情况
USED_PERCENT应低于80%，超过的话需分析使用情况。
```sql
SELECT S.INST_ID, S.TABLESPACE_NAME,
       TRUNC(SUM(S.TOTAL_BLOCKS * P.VALUE) / 1024 / 1024 / 1024) TOTSIZE_GB,
       SUM(S.TOTAL_BLOCKS) TOTAL_BLOCKS,
       SUM(S.USED_BLOCKS) USED_BLOCKS,
       SUM(S.FREE_BLOCKS) FREE_BLOCKS,
       ROUND(SUM(S.USED_BLOCKS) / SUM(S.TOTAL_BLOCKS), 4) * 100 || '%' USED_PERCENT
  FROM GV$SORT_SEGMENT S, V$PARAMETER P
 WHERE P.NAME = 'db_block_size'
 GROUP BY S.INST_ID, S.TABLESPACE_NAME
```

7. 检查UNDO空间使用情况
如果ACTIVE状态占用的UNDO空间较大（USED_PERCENT占比超过70%），需分析占用大原因。
```sql
SELECT U.TABLESPACE_NAME,
       U.STATUS,
       ROUND(SUM(U.BYTES) / 1024 / 1024, 2) USED_MB,
       ROUND(SUM(U.BYTES) / 1024 / 1024 / D.SIZE_MB, 2) USED_PERCENT
  FROM DBA_UNDO_EXTENTS U,
       (SELECT T.TABLESPACE_NAME, ROUND(SUM(BYTES) / 1024 / 1024, 2) SIZE_MB
          FROM DBA_TABLESPACES T, DBA_DATA_FILES F
         WHERE T.CONTENTS = 'UNDO'
           AND T.TABLESPACE_NAME = F.TABLESPACE_NAME
         GROUP BY T.TABLESPACE_NAME) D
 WHERE U.TABLESPACE_NAME = D.TABLESPACE_NAME
 GROUP BY U.TABLESPACE_NAME, U.STATUS, D.SIZE_MB
 ORDER BY 1
```

8. 查看数据库占用空间TOP10
关注占用空间TOP10对象是否正常。
```sql
SELECT *
  FROM (SELECT OWNER,
               SEGMENT_NAME,
               SEGMENT_TYPE,
               ROUND(SUM(BYTES) / 1024 / 1024 / 1024, 1) BYTE_GB
          FROM DBA_SEGMENTS
         GROUP BY OWNER, SEGMENT_NAME, SEGMENT_TYPE
         ORDER BY 4 DESC)
 WHERE ROWNUM <= 10
```

9. 检查锁表情况
查询到数据，间隔3分钟后再次查询，如果还是相同记录，说明长时间锁表，需要分析锁表原因。
```sql
SELECT INST_ID, SID, USERNAME, STATUS, EVENT, SQL_ID, SQL_EXEC_START, MODULE, MACHINE, LOGON_TIME
  FROM GV$SESSION S WHERE S.EVENT LIKE '%enq%';
```
