---
layout: post
title:  "2020-11-11-Java的单次分派和双重分派"
date:   2020-11-11 12:03:36 +0530
categories: Web
tags: [java, jvm]
---

### 单次分派

如图假设一个接口类Car有两个子类Toyota和Volkswagen，实现了方法`start()`。
如代码所示，`a`和`b`声明为Car类型，实际指向其子类Toyota和Volkswagen。因此Car称为`a`和`b`的静态类型，
而Toyota和Volkswagen分别为`a`和`b`的实际类型。
当`a`和`b`在调用抽象方法`start()`时，
JVM会在运行期指定实际类型Toyota和Volkswagen的函数`start()`作为抽象方法的实际入口，称为单次分派。

在这个例子中，JVM的单次分派是在运行期才指定的，因此也可以称为动态分派。
与之相对应的还有静态分派，一般方法的重载是静态分派的，方法的重写是动态分派的。

```java
Car a = new Toyota();
Car b = new Volkswagen();
a.start();
b.start();
```

![single-dispatch](https://phaedo.github.io/blog/post-assets/2020-11/single-dispatch.png)

### 双重分派

将`start()`函数加上一个参数改造为`startBy(Driver d)`。这种情况下`startBy(Driver d)`的调用结果由
函数的对象Car的实际类型以及参数Driver的实际类型共同决定的，即为双重分派。

```java
Driver joe = new MaleDriver();
Driver melania = new FemaleDriver();
Car a = new Toyota();
Car b = new Volkswagen();
a.startBy(joe);
b.startBy(melania);
```

![double-dispatch](https://phaedo.github.io/blog/post-assets/2020-11/double-dispatch.png)
